// Code generated by protoc-gen-go. DO NOT EDIT.
// source: workload.proto

/*
Package workload is a generated protocol buffer package.

It is generated from these files:
	workload.proto

It has these top-level messages:
	Bundles
	WorkloadEntry
	SpiffeID
	Empty
*/
package workload

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The Bundles message carries a group of workload SVIDs and their
// associated information. It also carries a TTL to inform the workload
// when it should check back next.
type Bundles struct {
	Bundles []*WorkloadEntry `protobuf:"bytes,1,rep,name=bundles" json:"bundles,omitempty"`
	Ttl     int32            `protobuf:"varint,2,opt,name=ttl" json:"ttl,omitempty"`
}

func (m *Bundles) Reset()                    { *m = Bundles{} }
func (m *Bundles) String() string            { return proto.CompactTextString(m) }
func (*Bundles) ProtoMessage()               {}
func (*Bundles) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Bundles) GetBundles() []*WorkloadEntry {
	if m != nil {
		return m.Bundles
	}
	return nil
}

func (m *Bundles) GetTtl() int32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

// The WorkloadEntry message carries a single SVID and all associated
// information, including CA bundles. All `bytes` types are ASN.1 DER encoded
type WorkloadEntry struct {
	// The SPIFFE ID of the SVID in this entry
	SpiffeId string `protobuf:"bytes,1,opt,name=spiffe_id,json=spiffeId" json:"spiffe_id,omitempty"`
	// The SVID itself
	Svid []byte `protobuf:"bytes,2,opt,name=svid,proto3" json:"svid,omitempty"`
	// The SVID private key
	SvidPrivateKey []byte `protobuf:"bytes,3,opt,name=svid_private_key,json=svidPrivateKey,proto3" json:"svid_private_key,omitempty"`
	// CA certificates belonging to the SVID
	SvidBundle []byte `protobuf:"bytes,4,opt,name=svid_bundle,json=svidBundle,proto3" json:"svid_bundle,omitempty"`
	// CA certificates that the workload should trust, mapped
	// by the trust domain of the external authority
	FederatedBundles map[string][]byte `protobuf:"bytes,5,rep,name=federated_bundles,json=federatedBundles" json:"federated_bundles,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *WorkloadEntry) Reset()                    { *m = WorkloadEntry{} }
func (m *WorkloadEntry) String() string            { return proto.CompactTextString(m) }
func (*WorkloadEntry) ProtoMessage()               {}
func (*WorkloadEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *WorkloadEntry) GetSpiffeId() string {
	if m != nil {
		return m.SpiffeId
	}
	return ""
}

func (m *WorkloadEntry) GetSvid() []byte {
	if m != nil {
		return m.Svid
	}
	return nil
}

func (m *WorkloadEntry) GetSvidPrivateKey() []byte {
	if m != nil {
		return m.SvidPrivateKey
	}
	return nil
}

func (m *WorkloadEntry) GetSvidBundle() []byte {
	if m != nil {
		return m.SvidBundle
	}
	return nil
}

func (m *WorkloadEntry) GetFederatedBundles() map[string][]byte {
	if m != nil {
		return m.FederatedBundles
	}
	return nil
}

// The SpiffeID message carries only a SPIFFE ID
type SpiffeID struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *SpiffeID) Reset()                    { *m = SpiffeID{} }
func (m *SpiffeID) String() string            { return proto.CompactTextString(m) }
func (*SpiffeID) ProtoMessage()               {}
func (*SpiffeID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SpiffeID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Represents a message with no fields
type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func init() {
	proto.RegisterType((*Bundles)(nil), "spire.api.workload.Bundles")
	proto.RegisterType((*WorkloadEntry)(nil), "spire.api.workload.WorkloadEntry")
	proto.RegisterType((*SpiffeID)(nil), "spire.api.workload.SpiffeID")
	proto.RegisterType((*Empty)(nil), "spire.api.workload.Empty")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Workload service

type WorkloadClient interface {
	// Fetch bundles for the SVID with the given SPIFFE ID
	FetchBundles(ctx context.Context, in *SpiffeID, opts ...grpc.CallOption) (*Bundles, error)
	// Fetch all bundles the workload is entitled to
	FetchAllBundles(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Bundles, error)
}

type workloadClient struct {
	cc *grpc.ClientConn
}

func NewWorkloadClient(cc *grpc.ClientConn) WorkloadClient {
	return &workloadClient{cc}
}

func (c *workloadClient) FetchBundles(ctx context.Context, in *SpiffeID, opts ...grpc.CallOption) (*Bundles, error) {
	out := new(Bundles)
	err := grpc.Invoke(ctx, "/spire.api.workload.Workload/FetchBundles", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workloadClient) FetchAllBundles(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Bundles, error) {
	out := new(Bundles)
	err := grpc.Invoke(ctx, "/spire.api.workload.Workload/FetchAllBundles", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Workload service

type WorkloadServer interface {
	// Fetch bundles for the SVID with the given SPIFFE ID
	FetchBundles(context.Context, *SpiffeID) (*Bundles, error)
	// Fetch all bundles the workload is entitled to
	FetchAllBundles(context.Context, *Empty) (*Bundles, error)
}

func RegisterWorkloadServer(s *grpc.Server, srv WorkloadServer) {
	s.RegisterService(&_Workload_serviceDesc, srv)
}

func _Workload_FetchBundles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpiffeID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkloadServer).FetchBundles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.workload.Workload/FetchBundles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkloadServer).FetchBundles(ctx, req.(*SpiffeID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Workload_FetchAllBundles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkloadServer).FetchAllBundles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.workload.Workload/FetchAllBundles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkloadServer).FetchAllBundles(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Workload_serviceDesc = grpc.ServiceDesc{
	ServiceName: "spire.api.workload.Workload",
	HandlerType: (*WorkloadServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchBundles",
			Handler:    _Workload_FetchBundles_Handler,
		},
		{
			MethodName: "FetchAllBundles",
			Handler:    _Workload_FetchAllBundles_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "workload.proto",
}

func init() { proto.RegisterFile("workload.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 345 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x52, 0x41, 0x4f, 0xf2, 0x40,
	0x14, 0x4c, 0x0b, 0xfd, 0x28, 0x0f, 0x3e, 0xc4, 0x17, 0x4d, 0x2a, 0x98, 0x88, 0x3d, 0xf5, 0xd4,
	0x03, 0x1e, 0x34, 0x7a, 0x12, 0x85, 0x84, 0x78, 0x31, 0xf5, 0xa0, 0xf1, 0x42, 0x8a, 0xbb, 0x8d,
	0x1b, 0x2a, 0x6d, 0xb6, 0x0b, 0xa6, 0xff, 0xc6, 0x5f, 0xe1, 0xef, 0x33, 0xbb, 0xdb, 0x35, 0x51,
	0x1b, 0x3d, 0x75, 0x3a, 0x6f, 0xde, 0xcb, 0xcc, 0xb4, 0xd0, 0x7b, 0xcd, 0xf8, 0x2a, 0xcd, 0x62,
	0x12, 0xe6, 0x3c, 0x13, 0x19, 0x62, 0x91, 0x33, 0x4e, 0xc3, 0x38, 0x67, 0xa1, 0x99, 0xf8, 0x0f,
	0xd0, 0x9a, 0x6c, 0xd6, 0x24, 0xa5, 0x05, 0x5e, 0x40, 0x6b, 0xa9, 0xa1, 0x67, 0x8d, 0x1a, 0x41,
	0x67, 0x7c, 0x1c, 0xfe, 0x5c, 0x08, 0xef, 0x2b, 0x30, 0x5d, 0x0b, 0x5e, 0x46, 0x66, 0x03, 0xfb,
	0xd0, 0x10, 0x22, 0xf5, 0xec, 0x91, 0x15, 0x38, 0x91, 0x84, 0xfe, 0xbb, 0x0d, 0xff, 0xbf, 0x88,
	0x71, 0x08, 0xed, 0x22, 0x67, 0x49, 0x42, 0x17, 0x8c, 0x78, 0xd6, 0xc8, 0x0a, 0xda, 0x91, 0xab,
	0x89, 0x39, 0x41, 0x84, 0x66, 0xb1, 0x65, 0x44, 0x5d, 0xe8, 0x46, 0x0a, 0x63, 0x00, 0x7d, 0xf9,
	0x5c, 0xe4, 0x9c, 0x6d, 0x63, 0x41, 0x17, 0x2b, 0x5a, 0x7a, 0x0d, 0x35, 0xef, 0x49, 0xfe, 0x56,
	0xd3, 0x37, 0xb4, 0xc4, 0x23, 0xe8, 0x28, 0xa5, 0xb6, 0xe3, 0x35, 0x95, 0x08, 0x24, 0xa5, 0xd3,
	0x21, 0x81, 0xdd, 0x84, 0x12, 0xca, 0x63, 0x41, 0x8d, 0xaa, 0xf0, 0x1c, 0x15, 0xf3, 0xf4, 0xcf,
	0x98, 0xe1, 0xcc, 0xac, 0x56, 0x5d, 0xe9, 0xf0, 0xfd, 0xe4, 0x1b, 0x3d, 0xb8, 0x82, 0xfd, 0x5a,
	0xa9, 0xac, 0x47, 0x9a, 0xd7, 0xa1, 0x25, 0xc4, 0x3d, 0x70, 0xb6, 0x71, 0xba, 0xa1, 0x55, 0x60,
	0xfd, 0x72, 0x6e, 0x9f, 0x59, 0xfe, 0x00, 0xdc, 0x3b, 0xdd, 0xca, 0x35, 0xf6, 0xc0, 0xfe, 0xec,
	0xca, 0x66, 0xc4, 0x6f, 0x81, 0x33, 0x7d, 0xc9, 0x45, 0x39, 0x7e, 0xb3, 0xc0, 0x35, 0x1e, 0x71,
	0x0e, 0xdd, 0x19, 0x15, 0x4f, 0xcf, 0xe6, 0x4b, 0x1e, 0xd6, 0x25, 0x32, 0x37, 0x07, 0xc3, 0xba,
	0xa9, 0x59, 0x9d, 0xc3, 0x8e, 0x3a, 0x75, 0x99, 0xa6, 0x86, 0x3a, 0xa8, 0xd3, 0x2b, 0x17, 0xbf,
	0x9e, 0x9a, 0xc0, 0xa3, 0x6b, 0xb8, 0xe5, 0x3f, 0xf5, 0x07, 0x9e, 0x7c, 0x04, 0x00, 0x00, 0xff,
	0xff, 0xf4, 0xb1, 0x0c, 0xd1, 0x93, 0x02, 0x00, 0x00,
}
